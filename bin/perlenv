#!/usr/bin/env perl
# VERSION

use strict;
use warnings;
use Cwd qw(abs_path);
use Config;
use Getopt::Long;
use File::Path qw(mkpath);
use File::Basename;

use Config::Tiny;
use Data::Printer;
use File::ShareDir;
use local::lib;

my ( $conf_file, $help, %params, $perlbrew, $share_dir, $version );

my $usage = 'Usage: perlenv [OPTIONS] [PERLENV_ROOT] ...
Example: perlenv /MYPROJ/env

Options:
   -c, --conf-file         Use/Generate conf file
   -h, --help              Print help message
   -q, --quiet             Suppress output except for errors
   -s, --self-contained    Release management support
   -v, --verbose           Show extra output
   -V, --version           Show version
';

# subs
sub cli_init {
    GetOptions(
        'c|conf-file=s'    => \$conf_file,
        'h|help'           => \$help,
        'q|quiet'          => \$params{quiet},
        's|self-contained' => \$params{self_contained},
        'v|verbose'        => \$params{verbose},
        'V|version'        => \$version
    ) or usage();

    return 1;
}

sub version {

    # TODO VERSION problem when doing dev work
    my $version = '0.1' || 'unknown';
    print "perlenv $version\n";
    exit;
}

sub usage {
    my $rt = shift || 0;

    print $usage;
    exit $rt;
}

sub perlenv_root_setup {
    my $conf = shift;

    if ( $ENV{PERLENV_ROOT} ) {
        $conf->{env}->{PERLENV_ROOT} = $ENV{PERLENV_ROOT};
    }
    elsif ( !$ARGV[0] ) {
        print "Must supply a PERLENV_ROOT\n";
        usage(1);
    }
    elsif ( $ARGV[0] !~ /\// ) {
        $conf->{env}->{PERLENV_ROOT} = abs_path( $ARGV[0] );
    }
    else {
        $conf->{env}->{PERLENV_ROOT} = $ARGV[0];
    }

    # TODO VERSION problem when doing dev work
    $conf->{env}->{PERLENV_VERSION} = '0.1';

    return 1;
}

sub perlbrew_setup {
    my $conf = shift;

    $conf->{env}->{PERLBREW_MANPATH} = $ENV{PERLBREW_MANPATH};
    $conf->{env}->{PERLBREW_PERL}    = $ENV{PERLBREW_PERL};
    $conf->{env}->{PERLBREW_VERSION} = $ENV{PERLBREW_VERSION};
    $conf->{env}->{PERLBREW_PATH}    = $ENV{PERLBREW_PATH};
    $conf->{env}->{PERLBREW_ROOT}    = $ENV{PERLBREW_ROOT};

    $conf->{env}->{PERLVERSION} = $ENV{PERLBREW_PERL};
    $conf->{env}->{PATH}        = $ENV{PERLBREW_PATH};

    $perlbrew = 1;

    return 1;
}

sub local_lib_setup {
    my $conf = shift;

    my $local_lib_root =
        $conf->{env}->{PERLENV_ROOT} . "/perl5/$conf->{env}->{PERLVERSION}";

    # TODO: Patch local::lib docs for DEACTIVATE/INTERPOLATE
    my %local_lib =
        local::lib->build_environment_vars_for( $local_lib_root, 0, 0 );

    # fixup vars
    $conf->{env}->{PATH} .= ':' . $local_lib{PATH};
    delete $local_lib{PATH};
    $local_lib{PERL_LOCAL_LIB_ROOT} =~ s/\$PERL_LOCAL_LIB_ROOT://;
    $local_lib{PERL5LIB} =~ s/\:\$PERL5LIB//;

    # merge %local_lib onto $conf->{env}
    while ( my ( $key, $value ) = each %local_lib ) {
        $conf->{env}->{$key} = $value;
    }

    return 1;
}

# create PERLENV_ROOT and artifacts
sub create_perlenv_root {
    my $conf = shift;

    mkpath "$conf->{env}->{PERLENV_ROOT}/bin";
    if ( !$params{quiet} ) {
        print "PERLENV_ROOT created: $conf->{env}->{PERLENV_ROOT}\n";
    }

    my $symlink_exists = eval {
        symlink( $Config{perlpath}, "$conf->{env}->{PERLENV_ROOT}/bin/perl" );
        1;
    };
    if ( !$symlink_exists ) {
        print
            "ERROR: Symlink creation failed: $conf->{env}->{PERLENV_ROOT}/bin/perl -> $Config{perlpath}\n";
        exit 1;
    }
    else {
        if ( !$params{quiet} ) {
            print
                "Symlink created: $conf->{env}->{PERLENV_ROOT}/bin/perl -> $Config{perlpath}\n";
        }
    }

    mkpath "$conf->{env}->{PERL_LOCAL_LIB_ROOT}";

    return 1;
}

sub create_plenv_script {
    my $conf = shift;

    open( my $tmpl, "<", "$share_dir/../share/plenv.tmpl" )
        or die "Cannot open < $share_dir/../share/plenv.tmpl: $!";
    open( my $plenv, ">", "$conf->{env}->{PERLENV_ROOT}/bin/plenv" )
        or die "Cannot open > $conf->{env}->{PERLENV_ROOT}/bin/plenv: $!";
    while (<$tmpl>) {
        if (/\{PLENV\}/) {
            foreach my $key ( sort keys $conf->{env} ) {
                print $plenv "export $key=\"$conf->{env}->{$key}\"\n";
            }
        }
        else {
            print $plenv $_;
        }
    }
    close($tmpl);
    close($plenv);
}

# run
cli_init();
version() if $version;
usage()   if $help;

eval { $share_dir = File::ShareDir::dist_dir('App-perlenv'); };
if ($@) {
    $share_dir = dirname( abs_path($0) );
}

# $conf is the default data structure for all exposed vars (e.g., [env])
# regardless if there is a perlenv.ini conf file or not
my $conf = Config::Tiny->new;
if ( $conf_file && !-e $conf_file ) {
    print "No such configuration file: $conf_file\n";
    exit 1;
}

perlenv_root_setup($conf);

# w/ perlbrew
if ( exists $ENV{PERLBREW_PATH} && exists $ENV{PERLBREW_PERL} ) {
    perlbrew_setup($conf);
}

# w/out perlbrew
else {
    $conf->{env}->{PATH}        = $Config{bin};
    $conf->{env}->{PERLVERSION} = $Config{version};
}

local_lib_setup($conf);
create_perlenv_root($conf);
delete $conf->{env}->{PERLVERSION};
create_plenv_script($conf);

p $conf;

1;

__END__

=head1 NAME

perlenv - A tool to create Perl environments

=head1 WARNING

B<This software is under development and considered alpha quality until version
v1.0. Things might be broke and/or less then ideal. Discussion, patches, and 
bugs filled on github are all welcome.>

=head1 NOTICE

If you think the design is helter skelter now is the time to speak up. Design,
at this point is minimal to incourage input and refinement. Please, file your
ideas, requests and bugs to github.

=head1 SYNOPSIS

    # Setup an app/project to run under perlenv
    #
    $ cd MYPROJ
    $ perlenv env
    # above command creats env/plenv
    # source env/plenv to set your shells Perl environment
    $ . env/plenv
    # MYPROJ/env/perl symlinks to first Perl on env C<PATH>
    # all modules will be installed to MYPROJ/env/perl5/PERLVERSION/
    # later you can revert your shell environment
    $ plenv-off

    # Setup an app/project to run under perlenv
    # using shell variable
    #
    $ export PERLENV_ROOT=/tmp/myproj/env
    $ perlenv
    $ . $PERLENV_ROOT/plenv

    # perlbrew detection is automatic assuming the shell
    # environment is already setup
    #
    $ perlbrew use perl-5.16.2
    $ cd MYPROJ
    $ perlenv env
    $ . env/plenv

    # setup to use Perl other then your PATH default
    #
    $ export PERLPATH=/opt/perl/5.14.2/
    $ cd MYPROJ
    $ /opt/perl/5.14.2/bin/perl perlenv env

    # self contained C<perlenv>
    #
    $ perlenv -s /home/foo/git/baz
    # C<PERLENV_ROOT> = /home/foo/git/baz/env
    # copies perlenv to C<PERLENV_ROOT>
    # C<PERLENV_ROOT>/perlenv.ini created
    # release management tools setup env via C<PERLENV_ROOT>/perlenv
    # on each target machine and exclude MYPROJ/env/plenv from VCS

=head1 DESCRIPTION

C<perlenv> is a tool to create virtual Perl environments. There are a number
of common environment dilemmas most projects with Perl code face.

=over

=item *

Which installed version of Perl to use.

=item *

Library installation, use and consistency.

=item *

Environment consistency as source code migrates from dev to ci, tst and prd.

=back

C<perlenv> extends the local::lib tool to create a consistent structure and
mechanism for creating consitent repeatable Perl shell environments. It features
built in perlbrew support, extendible Perl shell environment tweaking, ini file
configuration, self contained option for release management support and has zero
prerequisite modules.

=head1 INSTALLATION

Install C<perlenv> to the system Perl.

    cpanm App::Perlenv

Optionally, you can tweak your shell Perl environement variables with
L<local::lib|local::lib> and install C<perlenv> to a custom location.

    eval "$(perl -I$HOME/perl5/lib/perl5 -Mlocal::lib)"
    cpanm App::Perlenv

=head1 USING PERLENV

C<perlenv> works on a project basis, where a project is a directory typically
under the control of a VCS (e.g. Git, SVN, CVS, etc.). Some folks think of their
project as an application of sorts.

C<perlenv> creates a C<PERLENV_ROOT> directory inside your project wherever you
specifiy.

    # create C<PERLENV_ROOT> env/ in CWD, CWD/env is referred to as C<PERLENV_ROOT>
    $ perlenv env
    # or
    $ perlenv .

    # or name C<PERLENV_ROOT> whatever you like
    $ perlenv app

C<PERLENV_ROOT>/ contains a number of standard files and directories.

    $ ls -1 C<PERLENV_ROOT>/env
    perl -> $PERLPATH   # symlink
    plenv               # shell script to be sourced for all env vars
    perl5/$PERLVERSION  # lib home and target for lib installs

To set your shell environment up source the C<PERLENV_ROOT>/env/plenv.

    $ cd C<PERLENV_ROOT>
    $ . ./perlenv
    $ printenv | grep PERL

You can revert your environment easily with a shell function exported by
C<plenv>.

    $ plenv-off

=head1 ENVIRONMENT VARIABLES

C<perlenv> sniffs your environement for various shell variables before building
the C<plenv> shell script.

The version of Perl to use by default is the one that invoked C<perlenv>. For
example if the first Perl on your shell C<PATH> is /usr/bin/perl and you type

    $ perlenv .

Sourcing C<plenv> will set /usr/bin/perl as the default Perl. If you want to use
a differnt Perl than what C<perlenv> is invoked with then set the shell
C<PERLPATH> variable.

    $ export PERLPATH=/opt/perl/5.14.2/bin/perl

C<perlbrew> detection is built in assuming that you have already setup shell
variables with C<perlbrew> prior to invoking C<perlenv> or that a
C<PERLENV_ROOT>/init file produced by C<perlbrew> exists. Using the C<perlbrew>
init solution is noramally only used for the self contained option.

    $ cd MYPROJ
    $ perlbrew use perl-5.14.2
    $ perlenv env

    # or

    $ cd C<PROJECT_ROOT>
    $ mkdir env && cd env
    $ export PERLBREW_HOME=C<PROJECT_ROOT>/env
    $ perlbrew switch perl-5.14.2
    $ perlenv -s

=head1 CONFIGURATION

C<perlenv> makes use of an INI style config file where appropriate.

=head1 RELEASE MANAGEMENT

Release management is the discipline of managing software releases. For example,
imagine your developing an application, MYPROJ, on your local DEV machine. Your
using C<perlenv> to manage MYPROJ's Perl environment. Eventually, you want to
release MYPROJ to target machine(s) (TST, CI, PROD, etc.).

=begin text

 ---------        ---------
|   DEV   |  ->  |   TST   |
|  5.14.2 |      |  5.14.2 |
 ---------        ---------

     |
     V

 ---------
|   PRD   |
|  5.14.2 |
 ---------

=end text

Your using C<perlenv> to manage MYPROJ's Perl environment. In an ideal world
your DEV environment and the target systems are identical. The low bar is
all target environments must have the same Perl version down to the revision
number. Anything less is playing with fire. If they are identical or nearly
(i.e., other then Perl version) you can put MYPROJ's C<PERLENV_ROOT> under VCS
control and deliver it with the rest of your code base. Then your application
can source C<plenv> identical to how things work on DEV.

However, sometimes your DEV environment and your targets are sufficently
different. For example, what if DEV is a Linux OS, but the target machines are
SunOS? Or the DEV and target machines are the same OS but the former is 64 bit
architecture and the later 32 bit? To circumvent environment differences use
the C<perlenv> -s self contained option. This will copy C<perlenv> to
C<PERLENV_ROOT> along with the ini config file C<PERLENV_ROOT>/perlenv.ini

=head1 COMMAND-LINE OPTIONS

blah

=head1 SEE ALSO

L<local::lib|local::lib>, L<App::Perlbrew|App::Perlbrew> and L<virtualenv|virtualenv>

=head1 KNOWN BUGS

=over

=item *

Does not work on Windows. Patches welcome.

=back

=head1 ACKNOWLEDGMENTS

Thanks to Ricardo Signes, Chritopher J. Madsen, Jeff Thalhammer and others for
answering my endless toolchain questions which eventually spawned the birth of
C<perlenv>.

=head1 SPONSORS

Saint Micheal the Archangel, Saint Joseph of the Holy Family and Saint John
Vianney Curé d'Ars.

=cut
